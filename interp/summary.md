# Summary

## Terms and concepts

- abstract syntax
- abstract syntax tree
- associativity
- back end
- Backus-Naur Form (BNF)
- big step
- bytecode
- call by name
- call by value
- capture-avoiding substitution
- closure
- compiler
- concrete syntax
- constraint
- context-free grammar
- context-free language
- desugaring
- dynamic environment
- dynamic scope
- environment model
- evaluation
- fresh
- front end
- Hindley&ndash;Milner (HM) type inference algorithm
- implicit typing
- intermediate representation
- interpreter
- lambda calculus
- let polymorphism
- lexer
- machine configuration
- metavariable
- nonterminal
- operational semantics
- optimizing compiler
- parser
- precedence
- preliminary type variable
- preservation
- primitive operatiohn
- progress
- pushdown automata
- regular expression
- regular language
- relation
- semantic analysis
- short circuit
- small step
- source program
- static scope
- static typing
- stuck
- substitution
- substitution model
- symbol
- symbol table
- target program
- terminal
- token
- type annotation
- type checking
- type inference
- type reconstruction
- type safety
- type system
- typing context
- unification
- unifier
- value
- virtual machine
- well typed

## Further reading

* *Types and Programming Languages* by Benjamin C. Pierce, chapters 1-14, 22.
* *Modern Compiler Implementation* (in Java or ML) by Andrew W. Appel,
  chapters 1-5.
* *Automata and Computability* by Dexter C. Kozen, chapters 1-27.
* This [webpage](http://okmij.org/ftp/ML/generalization.html) documents how some of
  the internals of the OCaml type checker and inferencer.